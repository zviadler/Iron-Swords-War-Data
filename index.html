<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מאגר זיהוי לוחמים</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles to ensure full responsiveness and aesthetic appeal */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            direction: rtl; /* Default direction set by JS on load */
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column; /* Stack children vertically */
            justify-content: flex-start; /* Align to top */
            align-items: center; /* Center horizontally */
            min-height: 100vh;
            padding-top: 1.25rem; /* Add some padding at the top */
            padding-bottom: 1.25rem; /* Add some padding at the bottom */
        }

        .container {
            background: white;
            border-radius: 0.5rem; /* Rounded corners */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* Soft shadow */
            overflow: hidden;
            margin-bottom: 1.25rem; /* Margin between containers */
            width: 100%;
            max-width: 1600px; /* Max width for larger screens */
        }

        /* Redesigned header */
        .site-header {
            text-align: center;
            padding: 1.5rem 1rem;
            background: white;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
        }
        .site-header h1 {
            font-size: 2rem;
            font-weight: bold;
            color: #1a202c; /* Dark text for header title */
        }
        .site-header p {
            font-size: 1rem;
            color: #718096; /* Gray text for header subtitle */
            margin-top: 0.25rem;
        }

        /* Redesigned filters bar */
        .filters-bar {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            padding: 1rem 0;
            background: #f7fafc;
            border-top: 1px solid #e2e8f0;
            border-bottom: 1px solid #e2e8f0;
        }
        .filters-bar .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            width: auto; /* Allow filter groups to size naturally */
            align-items: flex-start; /* Align labels to the start */
        }
        .filters-bar label {
            font-size: 0.75rem;
            color: #4a5568;
        }
        .filters-bar select,
        .filters-bar input[type="text"] {
            padding: 0.4rem;
            font-size: 0.875rem;
            border: 1px solid #cbd5e0;
            border-radius: 0.375rem;
            background: white;
            min-width: 140px; /* Minimum width for filter inputs */
            flex-grow: 1; /* Allow inputs to grow within their group */
        }

        /* Responsive adjustments for controls */
        @media (max-width: 768px) {
            .filters-bar {
                flex-direction: column; /* Stack controls vertically on small screens */
                align-items: stretch; /* Stretch controls to full width */
                padding: 1rem; /* More padding on small screens */
            }
            .filters-bar .filter-group {
                width: 100%; /* Full width for filter group on small screens */
                align-items: stretch; /* Stretch labels and inputs */
            }
            .filters-bar select,
            .filters-bar input[type="text"],
            .btn {
                width: 100%; /* Full width for buttons and inputs */
                min-width: unset; /* Remove min-width on small screens */
            }
        }

        /* The .table-container is now applied to #contentArea when rendering a table */
        .table-container {
            overflow-x: auto; /* Enable horizontal scrolling for tables */
            max-height: 70vh; /* Max height for vertical scrolling */
            overflow-y: auto;
            width: 100%; /* Ensure container takes full width */
        }

        /* Styles for the dynamically created table */
        #contentArea table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem; /* Smaller font size for table content */
            min-width: 1200px; /* Minimum width to prevent squishing on small screens */
        }

        #contentArea th, #contentArea td {
            padding: 0.5rem 0.375rem;
            border: 1px solid #e2e8f0; /* Light border for cells */
            text-align: center;
            vertical-align: top;
        }

        #contentArea th {
            background: #4a5568; /* Darker header background */
            color: white;
            font-weight: bold;
            position: sticky; /* Sticky header */
            top: 0;
            z-index: 10;
            font-size: 0.625rem; /* Even smaller font for headers */
        }

        #contentArea tr:nth-child(even) {
            background-color: #f7fafc; /* Zebra striping */
        }

        #contentArea tr:hover {
            background-color: #edf2f7; /* Hover effect */
        }

        /* Color coding by rank */
        .high-ranking { background-color: #fed7d7 !important; } /* Reddish for high ranking */
        .field-commander { background-color: #feebc8 !important; } /* Orange for field commander */
        .regular-mujahid { background-color: #f0fff4 !important; } /* Greenish for regular */

        /* Text directions and sizes */
        .arabic { font-family: 'Arial Unicode MS', Arial, sans-serif; direction: rtl; }
        .english { direction: ltr; text-align: left; }
        .quote { font-style: italic; color: #4a5568; max-width: 200px; word-wrap: break-word; font-size: 0.7rem; }

        /* Organization colors */
        .org-hamas { color: #059669; font-weight: bold; }
        .org-dflp { color: #dc2626; font-weight: bold; }
        .org-mujahideen { color: #7c2d12; font-weight: bold; }
        .org-fatah { color: #1e40af; font-weight: bold; }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Responsive grid for stats */
            gap: 1rem;
            padding: 1.25rem;
            background: #f7fafc;
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        .stat-card {
            background: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .stat-number {
            font-size: 1.5rem; /* Larger font for numbers */
            font-weight: bold;
            color: #2b6cb0; /* Blue color for numbers */
            margin-bottom: 0.3125rem;
        }

        .btn {
            background: #48bb78; /* Green button */
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.75rem;
            transition: background-color 0.2s ease-in-out; /* Smooth transition */
            margin-top: 0.5rem; /* Space from other controls */
        }

        .btn:hover {
            background: #38a169; /* Darker green on hover */
        }

        .btn-secondary {
            background: #607D8B; /* Grayish blue for secondary button */
        }

        .btn-secondary:hover {
            background: #455A64; /* Darker gray blue on hover */
        }

        /* Column specific widths/breaks */
        .location { max-width: 80px; word-wrap: break-word; }
        .name-col { max-width: 120px; word-wrap: break-word; }

        /* Loading indicator styles */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 0.5rem;
            flex-direction: column;
            gap: 1rem;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #2c5282;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Card View styles (default for mobile, or when .table-view is absent) */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 1.5rem;
            padding: 1rem;
            overflow-x: hidden; /* Disable horizontal scrolling in card view */
        }
        .card {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            text-align: right; /* Ensure text is right-aligned */
        }
        .card h2 {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4a1d1d; /* Dark red for main heading */
            margin-bottom: 0.25rem;
        }
        .card .sub {
            font-size: 0.85rem;
            color: #555;
            margin-bottom: 0.5rem;
        }
        .card .meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: #333;
            border-top: 1px solid #eee;
            padding-top: 0.5rem;
            margin-top: 0.5rem;
        }
        .card .card-details {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px dashed #eee;
            font-size: 0.75rem;
            color: #666;
        }
        .card .card-details p {
            margin-bottom: 0.25rem;
        }
        .card .card-details strong {
            color: #4a5568; /* Darker gray for labels */
        }
        mark {
            background-color: #fffbbf; /* Light yellow for highlighting */
            padding: 0 0.1em;
            border-radius: 0.1em;
        }

        /* Default card view styles for screens up to 768px wide */
        @media (max-width: 768px) {
            body:not(.table-view) .table-container {
                overflow-x: hidden; /* Disable horizontal scrolling in card view on mobile */
            }
            body:not(.table-view) #contentArea table { /* Target table only when not in table-view */
                display: none; /* Hide the table in card view on mobile */
            }
            body:not(.table-view) #contentArea .card-grid {
                display: grid; /* Ensure grid is active in card view on mobile */
            }
        }

        /* Ensure table view is active on larger screens by default */
        @media (min-width: 769px) {
            body.table-view .table-container {
                overflow-x: auto; /* Enable horizontal scrolling for tables */
            }
            body.table-view #contentArea table {
                display: table; /* Ensure table is visible in table-view on desktop */
            }
            body.table-view #contentArea .card-grid {
                display: none; /* Hide card grid in table view on desktop */
            }
        }

        /* Styles for language toggle and family casualties field */
        .card-view td.family-casualties,
        td.family-casualties,
        .card .family {
            color: inherit; /* Reset color for family casualties from red */
            font-weight: normal; /* Reset font-weight for family casualties from bold */
        }
        .language-toggle {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background: #edf2f7;
            padding: 0.4rem 0.7rem;
            border-radius: 0.3rem;
            font-size: 0.75rem;
            cursor: pointer;
            box-shadow: 0 0 3px rgba(0,0,0,0.2);
            z-index: 1000; /* Ensure it's above other content */
        }

        /* Error Banner styles */
        .error-banner {
            background-color: #fee2e2; /* light red */
            border: 1px solid #f87171; /* slightly darker red */
            color: #b91c1c; /* dark red text */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            position: relative;
            text-align: right;
            width: 100%;
            max-width: 1600px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .error-banner strong {
            font-weight: bold;
        }
        .error-banner small {
            display: block;
            margin-top: 0.25rem;
            color: #881a1a;
        }
        .error-banner button {
            background: none;
            border: none;
            color: #b91c1c;
            font-size: 1.2rem;
            font-weight: bold;
            position: absolute;
            left: 1rem; /* Position 'X' to the left for RTL */
            top: 0.5rem;
            cursor: pointer;
            padding: 0 0.5rem;
        }

        /* Sorting indicators */
        .sort-indicator {
            display: inline-block;
            margin-left: 0.25rem;
            transition: transform 0.2s;
        }
        .sort-asc .sort-indicator {
            transform: rotate(180deg);
        }
        .sort-desc .sort-indicator {
            transform: rotate(0deg);
        }
    </style>
</head>
<body>
    <!-- Language toggle button - positioned fixed at top-left -->
    <div class="language-toggle" onclick="toggleLanguage()" id="langBtn" role="button" tabindex="0" aria-label="החלף שפה">English</div>

    <div class="container relative"> <!-- Added 'relative' for loading overlay positioning -->
        <header class="site-header" id="siteHeader">
            <h1 id="siteTitle">מאגר זיהוי לוחמים</h1>
            <p id="siteSub">נתונים מתעדכנים באופן רציף</p>
        </header>

        <div class="filters-bar">
            <div class="filter-group">
                <label for="locationFilter">מיקום:</label>
                <select id="locationFilter" onchange="filterTable()" class="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md">
                    <option value="">הכל</option>
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            
            <div class="filter-group">
                <label for="orgFilter">ארגון:</label>
                <select id="orgFilter" onchange="filterTable()" class="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md">
                    <option value="">הכל</option>
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            
            <div class="filter-group">
                <label for="rankFilter">דרגה:</label>
                <select id="rankFilter" onchange="filterTable()" class="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md">
                    <option value="">הכל</option>
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            
            <div class="filter-group">
                <label for="searchBox">חיפוש:</label>
                <input type="text" id="searchBox" placeholder="חפש שם, מיקום או תיאור..." class="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md">
            </div>
            
            <button class="btn" onclick="exportToCSV()" id="exportBtn" aria-label="ייצא נתונים לקובץ CSV">ייצא ל-CSV</button>
            <button class="btn btn-secondary" onclick="resetFilters()" id="resetBtn" aria-label="אפס את כל הפילטרים והחיפוש">איפוס פילטרים</button>
            <!-- New button for toggling view mode -->
            <button class="btn btn-secondary" onclick="toggleViewMode()" id="viewToggleBtn" aria-label="החלף בין תצוגת טבלה לתצוגת כרטיסים">עבור לתצוגת כרטיסים</button>
        </div>
        
        <!-- The contentArea will dynamically hold either the table or the card grid -->
        <div id="contentArea" class="table-container">
            <!-- Content will be populated by JavaScript -->
        </div>

        <!-- Loading Overlay -->
        <div id="loadingOverlay" class="loading-overlay hidden">
            <div class="spinner"></div>
            <p class="text-gray-700 text-lg">טוען נתונים...</p>
        </div>
    </div>
    
    <div class="container">
        <div class="stats">
            <div class="stat-card">
                <div class="stat-number" id="totalCombatants">0</div>
                <div>סה"כ לוחמים</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="totalCasualties">0</div>
                <div>סה"כ קורבנות</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="familyCasualties">0</div>
                <div>בני משפחה</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="highRanking">0</div>
                <div>בכירים</div>
            </div>
        </div>
    </div>

    <script>
        let originalTableData = []; // Stores the raw data from CSV
        let currentData = []; // Stores the currently filtered and sorted data for rendering and export
        let allLocations = new Set();
        let allOrganizations = new Set();
        let allRanks = new Set();

        // Initialize currentLang based on browser language or default to Hebrew
        let currentLang = (navigator.language || navigator.userLanguage).startsWith('he') ? 'he' : 'en';
        document.documentElement.lang = currentLang;
        document.documentElement.dir = currentLang === 'he' ? 'rtl' : 'ltr';
        // Set body direction directly to apply immediately
        document.body.style.direction = currentLang === 'he' ? 'rtl' : 'ltr';
        
        let isCardView = false; // Flag to track current view mode

        let currentSortColumn = null; // Stores the index of the column currently sorted
        let currentSortDirection = 'asc'; // Stores the current sort direction ('asc' or 'desc')

        // Debounce timer for filtering
        let renderDebounceTimer = null;

        // Virtual scrolling/pagination settings
        const VISIBLE_ROWS = 50; // Number of rows visible per page
        let currentPage = 0; // Current page for pagination

        // Define headers for data properties and their display labels in multiple languages
        const dataFieldKeys = [
            'post_id', 'combatant_id', 'date', 'location', 'location_details',
            'name_english', 'name_arabic', 'nickname', 'description_online',
            'rank_role', 'organization', 'activity', 'family_casualties_info',
            'casualties_count', 'additional_combatants', 'notes'
        ];

        // Translation labels for various UI elements
        const labels = {
            site_title: { he: "מאגר זיהוי לוחמים", en: "Combatant Identification Database" },
            site_sub: { he: "נתונים מתעדכנים באופן רציף", en: "Data updated continuously" },
            post_id: { he: "מס' פוסט", en: "Post ID" },
            combatant_id: { he: "מס' לוחם", en: "Combatant ID" },
            date: { he: "תאריך", en: "Date" },
            location: { he: "מיקום", en: "Location" },
            location_details: { he: "פירוט מיקום", en: "Location Details" },
            name_english: { he: "שם באנגלית", en: "English Name" },
            name_arabic: { he: "שם בערבית", en: "Arabic Name" },
            nickname: { he: "כינוי", en: "Nickname" },
            description_online: { he: "תיאור ברשת", en: "Online Description" },
            rank_role: { he: "דרגה/תפקיד", en: "Rank/Role" },
            organization: { he: "ארגון", en: "Organization" },
            activity: { he: "פעילות", en: "Activity" },
            family_casualties_info: { he: "בני משפחה", en: "Family" },
            casualties_count: { he: "מס' קורבנות", en: "Victims" },
            additional_combatants: { he: "לוחמים נוספים", en: "Other Fighters" },
            notes: { he: "הערות", en: "Notes" },
            toggle_view_card: { he: "עבור לתצוגת כרטיסים", en: "Switch to Card View" },
            toggle_view_table: { he: "עבור לתצוגת טבלה", en: "Switch to Table View" },
            search_placeholder: { he: "חפש שם, מיקום או תיאור...", en: "Search name, location or description..." },
            reset_filters: { he: "איפוס פילטרים", en: "Reset Filters" },
            export_csv: { he: "ייצא ל-CSV", en: "Export to CSV" },
            total_combatants: { he: "סה\"כ לוחמים", en: "Total Combatants" },
            total_casualties: { he: "סה\"כ קורבנות", en: "Total Casualties" },
            family_members: { he: "בני משפחה", en: "Family Members" },
            high_ranking: { he: "בכירים", en: "High Ranking" },
            loading_data: { he: "טוען נתונים...", en: "Loading data..." },
            no_matching_data: { he: "אין נתונים תואמים למסננים שנבחרו.", en: "No matching data for selected filters." },
            error_loading_data: { he: "שגיאה בטעינת הנתונים: ", en: "Error loading data: " },
            csv_file_error: { he: ". וודא שקובץ data.csv קיים ובפורמט תקין.", en: ". Ensure data.csv exists and is in a valid format." },
            previous_page: { he: "הקודם", en: "Previous" },
            next_page: { he: "הבא", en: "Next" },
            page_info: { he: "עמוד {current} מתוך {total}", en: "Page {current} of {total}" },
            error_http: { he: "שגיאת HTTP: ", en: "HTTP Error: " },
            error_empty_csv: { he: "קובץ CSV ריק", en: "Empty CSV file" },
            error_data_load_context: { he: "טעינת קובץ נתונים", en: "Data file loading" },
            error_no_source: { he: "לא ניתן לטעון נתונים מאף מקור", en: "Could not load data from any source" }
        };

        /**
         * Cleans a string to prevent XSS attacks by converting HTML entities.
         * @param {string} input - The string to sanitize.
         * @returns {string} The sanitized string.
         */
        function sanitizeInput(input) {
            const div = document.createElement('div');
            div.textContent = input;
            return div.innerHTML;
        }

        /**
         * Highlights occurrences of a search term within a given text.
         * Sanitizes both text and term to prevent XSS.
         * @param {string} text - The original text content.
         * @param {string} term - The search term to highlight.
         * @returns {string} The text with the search term wrapped in <mark> tags.
         */
        function highlight(text, term) {
            if (!term) return sanitizeInput(text);
            
            const sanitizedText = sanitizeInput(text);
            // Escape special characters in the term for use in RegExp
            const sanitizedTerm = sanitizeInput(term).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const re = new RegExp(`(${sanitizedTerm})`, 'gi');
            
            return sanitizedText.replace(re, '<mark>$1</mark>');
        }

        /**
         * Function to parse a CSV line, robustly handling quoted fields.
         * @param {string} line - The single line of CSV text to parse.
         * @returns {Array<string>} An array of strings, where each string is a field from the CSV line.
         */
        function parseCsvLine(line) {
            const result = [];
            let inQuote = false;
            let currentField = '';
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];
                
                if (char === '"') {
                    if (inQuote && nextChar === '"') { // Handle escaped double quotes ""
                        currentField += '"';
                        i++; // Skip the next quote
                    } else { // Toggle inQuote state
                        inQuote = !inQuote;
                    }
                } else if (char === ',' && !inQuote) { // End of field if not in a quote
                    result.push(currentField.trim());
                    currentField = '';
                } else { // Add character to current field
                    currentField += char;
                }
            }
            
            result.push(currentField.trim()); // Add the last field
            return result;
        }

        /**
         * Converts a raw CSV header string to a consistent, normalized key name.
         * This helps in reliably mapping CSV columns to JavaScript object properties.
         * For example, "מס' פוסט" might become "post_id".
         * @param {string} header - The raw header string from the CSV.
         * @returns {string} The normalized key name.
         */
        function normalizeHeader(header) {
            // Trim whitespace, convert to lowercase, and replace spaces with underscores.
            // Map specific Hebrew headers to English keys for consistency in JS.
            const normalized = header.trim().toLowerCase();
            switch (normalized) {
                case 'מס\' פוסט': return 'post_id';
                case 'מס\' לוחם': return 'combatant_id';
                case 'תאריך': return 'date';
                case 'מיקום': return 'location';
                case 'פירוט מיקום': return 'location_details';
                case 'שם באנגלית': return 'name_english';
                case 'שם בערבית': return 'name_arabic';
                case 'כינוי': return 'nickname';
                case 'תיאור ברשת': return 'description_online';
                case 'דרגה/תפקיד': return 'rank_role';
                case 'ארגון': return 'organization';
                case 'פעילות': return 'activity';
                case 'בני משפחה': return 'family_casualties_info';
                case 'מס\' קורבנות': return 'casualties_count';
                case 'לוחמים נוספים': return 'additional_combatants';
                case 'הערות': return 'notes';
                default: return normalized.replace(/ /g, '_').replace(/[^a-z0-9_]/g, ''); // Fallback for other headers
            }
        }

        /**
         * Shows the loading overlay with a given message.
         * @param {string} message - The message to display in the loading overlay.
         */
        function showLoadingState(message) {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.querySelector('p').textContent = message;
                overlay.classList.remove('hidden');
            }
        }

        /**
         * Hides the loading overlay.
         */
        function hideLoadingState() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.classList.add('hidden');
            }
        }

        /**
         * Displays a user-friendly error message in a dismissible banner.
         * @param {Error} error - The error object.
         * @param {string} context - The context where the error occurred.
         */
        function showErrorMessage(error, context) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-banner';
            errorDiv.innerHTML = `
                <strong>${currentLang === 'he' ? 'שגיאה' : 'Error'}:</strong> ${sanitizeInput(error.message)}
                <br><small>${currentLang === 'he' ? 'הקשר' : 'Context'}: ${sanitizeInput(context)}</small>
                <button onclick="this.parentElement.remove()" aria-label="${currentLang === 'he' ? 'סגור הודעת שגיאה' : 'Close error message'}">✕</button>
            `;
            // Insert at the top of the body, before the main container
            document.body.insertBefore(errorDiv, document.querySelector('.container'));
        }

        /**
         * Loads CSV data from a specified URL.
         * @param {string} url - The URL of the CSV file.
         * @returns {Promise<Array<object>>} A promise that resolves with the parsed data.
         */
        async function loadCSVData(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`${labels.error_http[currentLang]}${response.status}`);
            }
            const csvText = await response.text();
            if (!csvText.trim()) {
                throw new Error(labels.error_empty_csv[currentLang]);
            }
            
            const lines = csvText.split(/\r?\n/).filter(line => line.trim() !== '');
            if (lines.length <= 1) {
                throw new Error(labels.error_empty_csv[currentLang]);
            }

            const rawHeaders = parseCsvLine(lines[0]);
            const headers = rawHeaders.map(header => normalizeHeader(header));

            const data = lines.slice(1).map(line => {
                const values = parseCsvLine(line);
                let row = {};
                headers.forEach((header, i) => {
                    row[header] = values[i] ? values[i].trim() : '';
                });
                return row;
            });
            return data;
        }

        /**
         * Placeholder function for loading JSON data.
         * @param {string} url - The URL of the JSON data.
         */
        async function loadJSONData(url) {
            console.warn(`Attempting to load JSON data from ${url}. This function is a placeholder.`);
            throw new Error('JSON data loading not implemented.');
        }

        /**
         * Placeholder function for loading data from an API.
         * @param {string} url - The URL of the API endpoint.
         */
        async function loadAPIData(url) {
            console.warn(`Attempting to load API data from ${url}. This function is a placeholder.`);
            throw new Error('API data loading not implemented.');
        }


        /**
         * Loads data from the data.csv file (can be extended to multiple sources).
         * Parses the CSV content and populates the originalTableData array.
         * Also populates filter options based on the data.
         */
        async function loadData() {
            console.log('--- Starting loadData function ---');
            showLoadingState(labels.loading_data[currentLang]);

            try {
                // For this implementation, we stick to data.csv as the primary source.
                // The concept of multiple sources is shown, but not fully implemented here.
                originalTableData = await loadCSVData('data.csv');
                
                console.log('originalTableData after parsing:', originalTableData);

                // Clear existing filter sets before populating
                allLocations.clear();
                allOrganizations.clear();
                allRanks.clear();

                originalTableData.forEach(rowData => {
                    if (rowData.location) allLocations.add(rowData.location);
                    if (rowData.organization) allOrganizations.add(rowData.organization);
                    if (rowData.rank_role) allRanks.add(rowData.rank_role);
                });

                populateFilters();
                filterTable(); // Initial display of data
                console.log('--- loadData function finished successfully ---');
            } catch (error) {
                console.error('Error loading or parsing data:', error);
                showErrorMessage(error, labels.error_data_load_context[currentLang]);
                // Display no data message if loading fails
                currentData = []; // Ensure currentData is empty
                renderData(currentData);
                console.log('--- loadData function finished with error ---');
            } finally {
                hideLoadingState();
            }
        }

        /**
         * Populates the select filter options based on unique values found in the data.
         */
        function populateFilters() {
            const addOptions = (selectId, dataSet) => {
                const selectElement = document.getElementById(selectId);
                // Preserve current selection if it exists and is still valid
                const currentSelection = selectElement.value;
                selectElement.innerHTML = `<option value="">${currentLang === 'he' ? 'הכל' : 'All'}</option>`; // Keep "All" option
                
                Array.from(dataSet).sort().forEach(item => {
                    if (item) { // Ensure item is not empty
                        const option = document.createElement('option');
                        option.value = item;
                        option.textContent = item;
                        selectElement.appendChild(option);
                    }
                });
                // Restore selection if possible
                if (currentSelection && Array.from(dataSet).includes(currentSelection)) {
                    selectElement.value = currentSelection;
                } else {
                    selectElement.value = ''; // Reset if old selection is no longer valid
                }
            };

            addOptions('locationFilter', allLocations);
            addOptions('orgFilter', allOrganizations);
            addOptions('rankFilter', allRanks);
            console.log('Filters populated.');
            saveUserPreferences(); // Save preferences after filters are updated
        }

        /**
         * Filters the table rows based on selected filter criteria and search box input.
         * Updates the displayed table and recalculates statistics.
         */
        function filterTable() {
            console.log('--- Starting filterTable function ---');
            const locationFilter = document.getElementById('locationFilter').value.toLowerCase();
            const orgFilter = document.getElementById('orgFilter').value.toLowerCase();
            const rankFilter = document.getElementById('rankFilter').value.toLowerCase();
            const searchBox = document.getElementById('searchBox').value.toLowerCase();
            
            let visibleRowsData = [];
            originalTableData.forEach(rowData => {
                const location = rowData.location ? rowData.location.toLowerCase() : '';
                const organization = rowData.organization ? rowData.organization.toLowerCase() : '';
                const rank = rowData.rank_role ? rowData.rank_role.toLowerCase() : '';
                const nameEng = rowData.name_english ? rowData.name_english.toLowerCase() : '';
                const nameAr = rowData.name_arabic ? rowData.name_arabic.toLowerCase() : '';
                const description = rowData.description_online ? rowData.description_online.toLowerCase() : '';

                const locationMatch = !locationFilter || location.includes(locationFilter);
                const orgMatch = !orgFilter || organization.includes(orgFilter);
                const rankMatch = !rankFilter || rank.includes(rankFilter);
                const searchMatch = !searchBox || 
                                    nameEng.includes(searchBox) || 
                                    nameAr.includes(searchBox) || 
                                    location.includes(searchBox) ||
                                    organization.includes(searchBox) ||
                                    description.includes(searchBox);
                
                if (locationMatch && orgMatch && rankMatch && searchMatch) {
                    visibleRowsData.push(rowData);
                }
            });

            currentData = visibleRowsData; // Store filtered data
            currentPage = 0; // Reset to first page on new filter
            addSortingToTable(); // Apply sorting logic to headers
            sortTable(currentSortColumn, currentSortDirection, false); // Re-sort based on current sort state
            renderData(currentData); // Render the data (either table or cards)
            updateTextByLang(); // Update translated texts after rendering
            console.log(`Displayed ${currentData.length} rows after filtering.`);
            updateStats(currentData);
            saveUserPreferences(); // Save preferences after filtering
            console.log('--- filterTable function finished ---');
        }

        // Debounced version of filterTable for search input
        function debouncedFilterTable() {
            clearTimeout(renderDebounceTimer);
            renderDebounceTimer = setTimeout(filterTable, 150); // 150ms debounce
        }
        // Attach the debounced function to the search input
        document.getElementById('searchBox').addEventListener('input', debouncedFilterTable);
        // Remove onkeyup from HTML
        
        /**
         * Adds sorting functionality to table headers.
         * Only applies if in table view.
         */
        function addSortingToTable() {
            // Remove existing event listeners to prevent duplicates
            const oldHeaders = document.querySelectorAll('#contentArea th');
            oldHeaders.forEach(header => {
                const newHeader = header.cloneNode(true);
                header.parentNode.replaceChild(newHeader, header);
            });

            const headers = document.querySelectorAll('#contentArea th');
            headers.forEach((header, index) => {
                header.style.cursor = 'pointer';
                header.addEventListener('click', () => sortTable(index));

                // Add sort indicator if it doesn't exist
                if (!header.querySelector('.sort-indicator')) {
                    const span = document.createElement('span');
                    span.className = 'sort-indicator';
                    span.innerHTML = '↕'; // Default indicator
                    header.appendChild(span);
                }
                
                // Update indicator based on current sort state
                if (currentSortColumn === index) {
                    header.classList.remove('sort-asc', 'sort-desc'); // Clear previous
                    if (currentSortDirection === 'asc') {
                        header.classList.add('sort-asc');
                        header.querySelector('.sort-indicator').innerHTML = '↑';
                    } else {
                        header.classList.add('sort-desc');
                        header.querySelector('.sort-indicator').innerHTML = '↓';
                    }
                } else {
                    header.classList.remove('sort-asc', 'sort-desc');
                    header.querySelector('.sort-indicator').innerHTML = '↕';
                }
            });
        }

        /**
         * Sorts the currentData array based on the given column index.
         * Toggles sort direction if the same column is clicked again.
         * @param {number} columnIndex - The index of the column to sort by.
         * @param {string} [direction] - Optional. 'asc' or 'desc'. If not provided, it toggles.
         * @param {boolean} [shouldRender=true] - Optional. If false, rendering is skipped (e.g., when called from filterTable).
         */
        function sortTable(columnIndex, direction = null, shouldRender = true) {
            if (columnIndex === null) return; // Do not sort if no column selected

            const key = dataFieldKeys[columnIndex];
            if (!key) return; // Invalid column index

            if (currentSortColumn === columnIndex && direction === null) {
                currentSortDirection = (currentSortDirection === 'asc' ? 'desc' : 'asc');
            } else if (direction !== null) {
                currentSortDirection = direction;
            } else {
                currentSortColumn = columnIndex;
                currentSortDirection = 'asc';
            }

            currentData.sort((a, b) => {
                const aVal = String(a[key] || '').toLowerCase();
                const bVal = String(b[key] || '').toLowerCase();

                let comparison = aVal.localeCompare(bVal, currentLang);
                return currentSortDirection === 'desc' ? -comparison : comparison;
            });

            if (shouldRender) {
                currentPage = 0; // Reset to first page after sorting
                renderData(currentData);
                addSortingToTable(); // Re-apply sorting indicators
            }
        }


        /**
         * Updates all dynamic text elements in the UI based on the current language.
         */
        function updateTextByLang() {
            document.getElementById('langBtn').textContent = currentLang === 'he' ? 'English' : 'עברית';
            document.getElementById('siteTitle').textContent = labels.site_title[currentLang];
            document.getElementById('siteSub').textContent = labels.site_sub[currentLang];

            document.getElementById('searchBox')?.setAttribute('placeholder', labels.search_placeholder[currentLang]);
            
            const viewToggleBtn = document.getElementById('viewToggleBtn');
            if (viewToggleBtn) {
                viewToggleBtn.textContent = isCardView ? labels.toggle_view_table[currentLang] : labels.toggle_view_card[currentLang];
            }
            
            const resetBtn = document.getElementById('resetBtn');
            if (resetBtn) resetBtn.textContent = labels.reset_filters[currentLang];

            const exportBtn = document.getElementById('exportBtn');
            if (exportBtn) exportBtn.textContent = labels.export_csv[currentLang];

            // Update stats labels
            if (document.querySelector('#totalCombatants')) document.querySelector('#totalCombatants').nextElementSibling.textContent = labels.total_combatants[currentLang];
            if (document.querySelector('#totalCasualties')) document.querySelector('#totalCasualties').nextElementSibling.textContent = labels.total_casualties[currentLang];
            if (document.querySelector('#familyCasualties')) document.querySelector('#familyCasualties').nextElementSibling.textContent = labels.family_members[currentLang];
            if (document.querySelector('#highRanking')) document.querySelector('#highRanking').nextElementSibling.textContent = labels.high_ranking[currentLang];

            // Update filter labels
            if (document.querySelector('.filters-bar .filter-group:nth-child(1) label')) document.querySelector('.filters-bar .filter-group:nth-child(1) label').textContent = labels.location[currentLang] + ':';
            if (document.querySelector('.filters-bar .filter-group:nth-child(2) label')) document.querySelector('.filters-bar .filter-group:nth-child(2) label').textContent = labels.organization[currentLang] + ':';
            if (document.querySelector('.filters-bar .filter-group:nth-child(3) label')) document.querySelector('.filters-bar .filter-group:nth-child(3) label').textContent = labels.rank_role[currentLang] + ':';
            if (document.querySelector('.filters-bar .filter-group:nth-child(4) label')) document.querySelector('.filters-bar .filter-group:nth-child(4) label').textContent = labels.search_placeholder[currentLang].split(' ')[0] + ':'; // "חיפוש:" / "Search:"

            // Update filter options (e.g., "All" option)
            const filterSelects = ['locationFilter', 'orgFilter', 'rankFilter'];
            filterSelects.forEach(selectId => {
                const selectElement = document.getElementById(selectId);
                if (selectElement && selectElement.options.length > 0) {
                    selectElement.options[0].textContent = currentLang === 'he' ? 'הכל' : 'All';
                }
            });
            
            // Update pagination buttons if they exist
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            const pageInfoSpan = document.getElementById('pageInfo');
            if (prevBtn) prevBtn.textContent = labels.previous_page[currentLang];
            if (nextBtn) nextBtn.textContent = labels.next_page[currentLang];
            if (pageInfoSpan) {
                 const totalPages = Math.ceil(currentData.length / VISIBLE_ROWS);
                 pageInfoSpan.textContent = labels.page_info[currentLang]
                    .replace('{current}', currentPage + 1)
                    .replace('{total}', totalPages === 0 ? 1 : totalPages); // Handle 0 total pages
            }
        }

        /**
         * Toggles the view mode between table and card view.
         * Updates the global `isCardView` flag and button text, then re-renders data.
         */
        function toggleViewMode() {
            isCardView = !isCardView;
            const btn = document.getElementById('viewToggleBtn');
            if (isCardView) {
                document.body.classList.remove('table-view'); // Switch to card view (no table-view class)
                btn.textContent = labels.toggle_view_table[currentLang];
            } else {
                document.body.classList.add('table-view'); // Switch to table view
                btn.textContent = labels.toggle_view_card[currentLang];
            }
            currentPage = 0; // Reset to first page on view mode change
            renderData(currentData); // Re-render data based on new view mode
            saveUserPreferences(); // Save preferences after view mode change
        }

        /**
         * Renders the data either as a table or a grid of cards based on `isCardView`.
         * Implements basic pagination for table view.
         * @param {Array<object>} data - The array of data objects to render.
         */
        function renderData(data) {
            const container = document.getElementById('contentArea');
            container.innerHTML = ''; // Clear existing content

            // Handle empty data
            if (data.length === 0) {
                container.innerHTML = `<p class="text-gray-500 font-bold text-center py-4">${labels.no_matching_data[currentLang]}</p>`;
                return;
            }

            const searchTerm = document.getElementById('searchBox')?.value.toLowerCase() || '';

            if (isCardView) {
                container.classList.remove('table-container'); // Remove table scrolling for card view
                const grid = document.createElement('div');
                grid.className = 'card-grid';

                data.forEach(row => {
                    const card = document.createElement('div');
                    card.className = 'card';

                    // Apply rank-based styling to the card itself
                    let rankClass = '';
                    const lowerRank = row.rank_role ? row.rank_role.toLowerCase() : '';
                    if (lowerRank.includes('leader') || lowerRank.includes('prominent')) {
                        rankClass = 'high-ranking';
                    } else if (lowerRank.includes('commander')) {
                        rankClass = 'field-commander';
                    } else if (lowerRank.includes('mujahid') || lowerRank.includes('fighter')) {
                        rankClass = 'regular-mujahid';
                    }
                    if (rankClass) card.classList.add(rankClass);

                    let orgClass = '';
                    const org = row.organization ? row.organization.toLowerCase() : '';
                    if (org.includes('hamas')) orgClass = 'org-hamas';
                    else if (org.includes('dflp')) orgClass = 'org-dflp';
                    else if (org.includes('mujahideen')) orgClass = 'org-mujahideen';
                    else if (org.includes('fatah')) orgClass = 'org-fatah';
                    
                    // Build card content with highlighting and detailed info using labels for titles
                    // Main title and subtitle
                    card.innerHTML = `
                        <h2 class="${orgClass}">${highlight(row.name_english || '', searchTerm)} | ${highlight(row.name_arabic || '', searchTerm)}</h2>
                        <div class="sub">${highlight(row.description_online || '', searchTerm)}</div>
                        <div class="meta">
                            <span>📍 ${highlight(row.location || '', searchTerm)}</span>
                            <span>📅 ${highlight(row.date || '', searchTerm)}</span>
                        </div>
                        <div class="card-details"></div>
                    `;
                    
                    const cardDetailsDiv = card.querySelector('.card-details');

                    // Add all other fields dynamically, skipping empty/dash ones
                    dataFieldKeys.forEach(key => {
                        // Skip fields already rendered in h2, sub, meta
                        if (['name_english', 'name_arabic', 'description_online', 'location', 'date'].includes(key)) {
                            return;
                        }

                        const value = row[key];
                        // Only add if value is not empty or just a dash
                        if (value && String(value).trim() !== '' && String(value).trim() !== '-') {
                            const p = document.createElement('p');
                            // Apply 'family' class if it's family_casualties_info
                            if (key === 'family_casualties_info') {
                                p.classList.add('family'); // Use 'family' class for specific styling
                            }
                            p.innerHTML = `<strong>${labels[key][currentLang]}:</strong> ${highlight(String(value), searchTerm)}`;
                            cardDetailsDiv.appendChild(p);
                        }
                    });

                    grid.appendChild(card);
                });

                container.appendChild(grid);
            } else {
                // Render table view
                container.classList.add('table-container'); // Add table scrolling for table view

                const tableHTML = `
                    <table class="w-full border-collapse text-sm">
                        <thead>
                            <tr>
                                ${dataFieldKeys.map(key => `<th>${labels[key][currentLang]} <span class="sort-indicator">↕</span></th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>`;
                container.innerHTML = tableHTML;

                const tbody = container.querySelector('tbody');
                const startIndex = currentPage * VISIBLE_ROWS;
                const endIndex = startIndex + VISIBLE_ROWS;
                const visibleData = data.slice(startIndex, endIndex);

                visibleData.forEach(rowData => {
                    let trClasses = [];
                    const lowerRank = rowData.rank_role ? rowData.rank_role.toLowerCase() : '';
                    if (lowerRank.includes('leader') || lowerRank.includes('prominent')) {
                        trClasses.push('high-ranking');
                    } else if (lowerRank.includes('commander')) {
                        trClasses.push('field-commander');
                    } else if (lowerRank.includes('mujahid') || lowerRank.includes('fighter')) {
                        trClasses.push('regular-mujahid');
                    }

                    // Map rowData keys to dataFieldKeys order for table display
                    const orderedCells = dataFieldKeys.map(key => rowData[key]);

                    const tr = document.createElement('tr');
                    if (trClasses.length > 0) tr.classList.add(...trClasses);

                    const cellHTML = orderedCells.map((cellContent, index) => {
                        let tdClasses = [];
                        const currentKey = dataFieldKeys[index];

                        if (currentKey === 'location') tdClasses.push('location');
                        if (currentKey === 'name_english') tdClasses.push('name-col', 'english');
                        if (currentKey === 'name_arabic') tdClasses.push('name-col', 'arabic');
                        if (currentKey === 'description_online') tdClasses.push('quote');
                        if (currentKey === 'organization') {
                            const org = rowData.organization ? rowData.organization.toLowerCase() : '';
                            if (org.includes('hamas')) tdClasses.push('org-hamas');
                            else if (org.includes('dflp')) tdClasses.push('org-dflp');
                            else if (org.includes('mujahideen')) tdClasses.push('org-mujahideen');
                            else if (org.includes('fatah')) tdClasses.push('org-fatah');
                        }
                        return `<td class="${tdClasses.join(' ')}">${highlight(String(cellContent || ''), searchTerm)}</td>`;
                    }).join('');
                    tr.innerHTML = cellHTML;
                    tbody.appendChild(tr);
                });

                // Add pagination controls below the table
                const totalPages = Math.ceil(data.length / VISIBLE_ROWS);
                const paginationDiv = document.createElement('div');
                paginationDiv.className = 'flex justify-center items-center gap-4 mt-4';
                paginationDiv.innerHTML = `
                    <button id="prevPageBtn" class="btn btn-secondary" onclick="changePage(-1)" ${currentPage === 0 ? 'disabled' : ''}>${labels.previous_page[currentLang]}</button>
                    <span id="pageInfo" class="text-gray-700">${labels.page_info[currentLang].replace('{current}', currentPage + 1).replace('{total}', totalPages === 0 ? 1 : totalPages)}</span>
                    <button id="nextPageBtn" class="btn btn-secondary" onclick="changePage(1)" ${currentPage >= totalPages - 1 ? 'disabled' : ''}>${labels.next_page[currentLang]}</button>
                `;
                container.appendChild(paginationDiv);
                
                addSortingToTable(); // Apply sorting listeners after table is rendered
            }
        }

        /**
         * Changes the current page for table pagination.
         * @param {number} delta - -1 for previous page, 1 for next page.
         */
        function changePage(delta) {
            const totalPages = Math.ceil(currentData.length / VISIBLE_ROWS);
            const newPage = currentPage + delta;
            if (newPage >= 0 && newPage < totalPages) {
                currentPage = newPage;
                renderData(currentData);
                updateTextByLang(); // Update page info and button states
            }
        }


        /**
         * Updates the statistics displayed in the stat cards.
         * Calculates stats based on the currently visible (filtered) data.
         * @param {Array<object>} data - An array of data objects (rows) currently displayed in the table.
         */
        function updateStats(data) {
            console.log('Updating stats...');
            let totalCombatants = 0;
            let totalCasualties = 0;
            let familyCasualties = 0;
            let highRanking = 0;
            
            data.forEach(rowData => {
                const combatantNumbers = rowData.combatant_id || '';
                const casualtyCount = parseInt(rowData.casualties_count) || 0;
                const familyInfo = rowData.family_casualties_info || '';
                const rank = rowData.rank_role ? rowData.rank_role.toLowerCase() : '';
                
                // Count combatants (handle ranges like 264-265 or comma separated)
                if (combatantNumbers.includes(',') && combatantNumbers.includes('-')) {
                    totalCombatants += combatantNumbers.split(',').reduce((acc, current) => {
                        if (current.includes('-')) {
                            return acc + (parseInt(current.split('-')[1]) - parseInt(current.split('-')[0]) + 1);
                        }
                        return acc + 1;
                    }, 0);
                } else if (combatantNumbers.includes('-')) {
                    const range = combatantNumbers.split('-');
                    if (range.length === 2 && !isNaN(parseInt(range[0])) && !isNaN(parseInt(range[1]))) {
                        totalCombatants += parseInt(range[1]) - parseInt(range[0]) + 1;
                    } else {
                        totalCombatants += 1; // Fallback for malformed range
                    }
                } else if (combatantNumbers.includes(',')) {
                     totalCombatants += combatantNumbers.split(',').length;
                }
                else if (combatantNumbers) { // Ensure it's not empty
                    totalCombatants += 1;
                }
                
                totalCasualties += casualtyCount;
                
                if (familyInfo && familyInfo.trim() !== '-' && familyInfo.trim() !== '') {
                    familyCasualties += casualtyCount; // Simple count if family info is present
                }
                
                if (rank.includes('leader') || rank.includes('commander') || rank.includes('prominent')) {
                    highRanking += 1;
                }
            });
            
            document.getElementById('totalCombatants').textContent = totalCombatants;
            document.getElementById('totalCasualties').textContent = totalCasualties;
            document.getElementById('familyCasualties').textContent = familyCasualties;
            document.getElementById('highRanking').textContent = highRanking;
            console.log('Stats updated:', { totalCombatants, totalCasualties, familyCasualties, highRanking });
        }

        /**
         * Exports the currently visible table data to a CSV file.
         */
        function exportToCSV() {
            if (currentData.length === 0) {
                console.warn("No data to export.");
                return;
            }

            // Use dataFieldKeys for CSV headers in the correct order, and get translated headers
            const headers = dataFieldKeys.map(key => `"${labels[key][currentLang].replace(/"/g, '""')}"`).join(',') + '\n';
            let csvContent = headers;
            
            currentData.forEach(rowData => {
                // Manually list fields in the order they appear in dataFieldKeys
                const orderedValues = dataFieldKeys.map(key => rowData[key]);
                
                const rowDataCsv = orderedValues.map(cellContent => {
                    return '"' + String(cellContent || '').replace(/"/g, '""') + '"'; // Quote and escape double quotes
                }).join(',');
                csvContent += rowDataCsv + '\n';
            });
            
            // Create a Blob and download the CSV file
            const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'combatants_data.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        /**
         * Resets all filter selections and the search box, then re-filters the table.
         */
        function resetFilters() {
            document.getElementById('locationFilter').value = '';
            document.getElementById('orgFilter').value = '';
            document.getElementById('rankFilter').value = '';
            document.getElementById('searchBox').value = '';
            currentSortColumn = null; // Reset sorting
            currentSortDirection = 'asc';
            filterTable();
            console.log('Filters have been reset.');
        }

        /**
         * Saves user preferences (language, view mode, filters) to sessionStorage.
         */
        function saveUserPreferences() {
            const prefs = {
                language: currentLang,
                viewMode: isCardView,
                filters: {
                    location: document.getElementById('locationFilter').value,
                    organization: document.getElementById('orgFilter').value,
                    rank: document.getElementById('rankFilter').value,
                    search: document.getElementById('searchBox').value
                },
                sort: {
                    column: currentSortColumn,
                    direction: currentSortDirection
                }
            };
            sessionStorage.setItem('userPrefs', JSON.stringify(prefs));
            console.log('User preferences saved.');
        }

        /**
         * Loads user preferences from sessionStorage and applies them.
         */
        function loadUserPreferences() {
            try {
                const prefs = JSON.parse(sessionStorage.getItem('userPrefs') || '{}');
                
                // Apply language preference
                if (prefs.language) {
                    currentLang = prefs.language;
                    document.documentElement.lang = currentLang;
                    document.documentElement.dir = currentLang === 'he' ? 'rtl' : 'ltr';
                    document.body.style.direction = currentLang === 'he' ? 'rtl' : 'ltr';
                }

                // Apply view mode preference (will be handled by DOMContentLoaded for initial render)
                if (typeof prefs.viewMode === 'boolean') {
                    isCardView = prefs.viewMode;
                    // Initial body class will be set in DOMContentLoaded listener below
                }

                // Apply filter preferences
                if (prefs.filters) {
                    Object.entries(prefs.filters).forEach(([key, value]) => {
                        const element = document.getElementById(key + (key === 'search' ? 'Box' : 'Filter'));
                        if (element && value !== undefined) { // Check for undefined to allow empty strings
                            element.value = value;
                        }
                    });
                }

                // Apply sort preferences
                if (prefs.sort && prefs.sort.column !== null) {
                    currentSortColumn = prefs.sort.column;
                    currentSortDirection = prefs.sort.direction;
                }
                console.log('User preferences loaded.');
            } catch (error) {
                console.warn('Failed to load user preferences from sessionStorage:', error);
            }
        }
        
        // Initial setup on page load
        window.addEventListener('DOMContentLoaded', () => {
            loadUserPreferences(); // Load preferences first

            // Set initial view mode based on loaded preference or screen width
            const initialViewMode = isCardView; // Use loaded preference
            
            // If no preference loaded, or if screen is small, default to card view
            if (window.innerWidth <= 768 && !sessionStorage.getItem('userPrefs')) {
                 isCardView = true;
            } else if (sessionStorage.getItem('userPrefs') && typeof initialViewMode === 'boolean') {
                 isCardView = initialViewMode; // Use loaded preference
            } else {
                 isCardView = false; // Default to table view on larger screens if no preference
            }


            if (isCardView) {
                document.body.classList.remove('table-view'); // Ensure table-view is off for card view
            } else {
                document.body.classList.add('table-view'); // Ensure table-view is on for table view
            }
            
            updateTextByLang(); // Update all text elements including the view toggle button
            loadData(); // Load data after initial view mode and preferences are set
        });

        // Event listener for when filters change to save preferences
        document.getElementById('locationFilter').addEventListener('change', saveUserPreferences);
        document.getElementById('orgFilter').addEventListener('change', saveUserPreferences);
        document.getElementById('rankFilter').addEventListener('change', saveUserPreferences);
        // Note: searchBox uses debouncedFilterTable which already calls saveUserPreferences via filterTable()
    </script>
</body>
</html>
